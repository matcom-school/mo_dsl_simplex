// TODO DEF => FUNC , TODO IN DEF => PARAMS, TODO DEF IN => forAll

// {} is syntax sugar for 
// Def N like x | x in Naturals
Let N : { x | x in Naturals }; // => N() 
Let X : { x | x in Variables }; // => X()
Let R : { X | X in Reals };  // => R()

Let NPlus : { x | x in N, x > 0  };  => NPlus()

// without syntax sugar  
// Let n,m in N Def Matrix like M | M in (R^n)^m
Let Matrix : { M | M in (R^n)^m, n,m in N }; // => Matrix(n,m)

// ^n is syntax sugar for
// Let n in N, Def RNSet like {f(0) ... f(i)} | f:(i in N) => x in R, i < n; // => RNSet(n)

// The func compose => g(a,b,m,c,d,j) == g(m(a,b), j(c,d))
Let n,m in N, A in Matrix(n,m),                                     
  Def transposed like transposed(A) = ATransposed | AtTransposed[i,j] = A[j,i], 
    i,j in N, i <= n, j <= m;  // => ATransposed(Matrix(n,m))

// ATransposed se define como ATransposed(n,m,A)
// But se infiere que ATransposed(A) y A = Matrix(n,m)
// n,m se ponen en la definicion de ATransposed para poder comparars


Let n in N, c in R^n and x in X^n 
  Def LinealEq like transposed(c) * x // => LinealEq(c) y c(n)
// en este caso se podria llegar a inferir n por c y dejarlo en LinealEq(c)
// considerando que el set de variables nunca es parametros 
// pero lo veo turbio

Let n,m in N, x in X^n, A in Matrix(n,m), b in R^n
  Def SystemEq like A*x=b; // => SystemEq(A, b) y A(n,m), b(n)

Let n in N, Axb is SystemEq, ctx is LinealEq
  Def LOP like ????

// Problemas al referenciar las variables 